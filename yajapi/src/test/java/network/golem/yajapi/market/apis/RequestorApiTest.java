/*
 * Yagna Market API
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase). 
 *
 * OpenAPI spec version: 1.6.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package network.golem.yajapi.market.apis;

import network.golem.yajapi.market.ApiException;
import network.golem.yajapi.market.models.Agreement;
import network.golem.yajapi.market.models.AgreementProposal;
import network.golem.yajapi.market.models.Demand;
import network.golem.yajapi.market.models.ErrorMessage;
import network.golem.yajapi.market.models.PropertyQueryReply;
import network.golem.yajapi.market.models.Proposal;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for RequestorApi
 */
@Ignore
public class RequestorApiTest {

    private final RequestorApi api = new RequestorApi();

    /**
     * Cancels agreement.
     *
     * Causes:   - the awaiting &#x60;approveAgreement&#x60; on Provider side to return with &#x60;Cancelled&#x60; response.   - the awaiting &#x60;waitForApproval&#x60; local call to return with &#x60;Cancelled&#x60; response. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelAgreementTest() throws ApiException {
        String agreementId = null;
        api.cancelAgreement(agreementId);

        // TODO: test validations
    }
    /**
     * Reads Market responses to published Demand.
     *
     * This is a blocking operation. It will not return until there is at least one new event.  **Note**: When &#x60;collectOffers&#x60; is waiting, simultaneous call to &#x60;unsubscribeDemand&#x60; on the same &#x60;subscriptionId&#x60; should result in \&quot;Subscription does not exist\&quot; error returned from &#x60;collectOffers&#x60;.  **Note**: Specification requires this endpoint to support list of specific Proposal Ids to listen for messages related only to specific Proposals. This is not covered yet. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void collectOffersTest() throws ApiException {
        String subscriptionId = null;
        Float timeout = null;
        Integer maxEvents = null;
        List<Object> response = api.collectOffers(subscriptionId, timeout, maxEvents);

        // TODO: test validations
    }
    /**
     * Sends Agreement proposal to the Provider.
     *
     * Signs self-created Agreement and sends it to the Provider. This call should immediately follow &#x60;createAgreement&#x60;. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void confirmAgreementTest() throws ApiException {
        String agreementId = null;
        api.confirmAgreement(agreementId);

        // TODO: test validations
    }
    /**
     * Responds with a bespoke Demand to received Offer.
     *
     * Creates and sends a modified version of original Demand (a counter-proposal) adjusted to previously received Proposal (ie. Offer). Changes Proposal state to &#x60;Draft&#x60;. Returns created Proposal id. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void counterProposalDemandTest() throws ApiException {
        Proposal body = null;
        String subscriptionId = null;
        String proposalId = null;
        String response = api.counterProposalDemand(body, subscriptionId, proposalId);

        // TODO: test validations
    }
    /**
     * Creates Agreement from selected Proposal.
     *
     * Initiates the Agreement handshake phase.  Formulates an Agreement artifact from the Proposal indicated by the received Proposal Id. Created Agreement is in &#x60;Proposal&#x60; state.  The Approval Expiry Date is added to Agreement artifact and implies the effective timeout on the whole Agreement Confirmation sequence.  A successful call to &#x60;createAgreement&#x60; shall immediately be followed by a &#x60;confirmAgreement&#x60; and &#x60;waitForApproval&#x60; call in order to listen for responses from the Provider.  **Note**: Moves given Proposal to &#x60;Approved&#x60; state. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createAgreementTest() throws ApiException {
        AgreementProposal body = null;
        String response = api.createAgreement(body);

        // TODO: test validations
    }
    /**
     * Fetches agreement with given agreement id.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getAgreementTest() throws ApiException {
        String agreementId = null;
        Agreement response = api.getAgreement(agreementId);

        // TODO: test validations
    }
    /**
     * Fetches all active Demands which have been published by the Requestor.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getDemandsTest() throws ApiException {
        List<Object> response = api.getDemands();

        // TODO: test validations
    }
    /**
     * Fetches Proposal (Offer) with given id.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getProposalOfferTest() throws ApiException {
        String subscriptionId = null;
        String proposalId = null;
        Proposal response = api.getProposalOffer(subscriptionId, proposalId);

        // TODO: test validations
    }
    /**
     * Handles dynamic property query.
     *
     * The Market Matching Mechanism, when resolving the match relation for the specific Demand-Offer pair, is to detect the “dynamic” properties required (via constraints) by the other side. At this point, it is able to query the issuing node for those properties and submit the other side’s requested properties as the context of the query.  **Note**: The property query responses may be submitted in “chunks”, ie. the responder may choose to resolve ‘quick’/lightweight’ properties faster and provide response sooner, while still working on more time-consuming properties in the background. Therefore the response contains both the resolved properties, as well as list of properties which responder knows still require resolution.  **Note**: This method must be implemented for Market API Capability Level 2. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void queryReplyDemandsTest() throws ApiException {
        PropertyQueryReply body = null;
        String subscriptionId = null;
        String queryId = null;
        api.queryReplyDemands(body, subscriptionId, queryId);

        // TODO: test validations
    }
    /**
     * Rejects Proposal (Offer).
     *
     * Effectively ends a Negotiation chain - it explicitly indicates that the sender will not create another counter-Proposal. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void rejectProposalOfferTest() throws ApiException {
        String subscriptionId = null;
        String proposalId = null;
        api.rejectProposalOffer(subscriptionId, proposalId);

        // TODO: test validations
    }
    /**
     * Publishes Requestor capabilities via Demand.
     *
     * Demand object can be considered an \&quot;open\&quot; or public Demand, as it is not directed at a specific Provider, but rather is sent to the market so that the matching mechanism implementation can associate relevant Offers.  **Note**: it is an \&quot;atomic\&quot; operation, ie. as soon as Subscription is placed, the Demand is published on the market. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void subscribeDemandTest() throws ApiException {
        Demand body = null;
        String response = api.subscribeDemand(body);

        // TODO: test validations
    }
    /**
     * Terminates approved Agreement.
     *
     * Method to finish/close the Agreement while in &#x60;Approved&#x60; state. The other party gets notified about calling party decision to terminate a \&quot;running\&quot; agreement. **Note**: Can be invoked at any time after Agreement was approved by both sides. Financial and reputational consequences are not defined by this specification. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void terminateAgreementTest() throws ApiException {
        String agreementId = null;
        api.terminateAgreement(agreementId);

        // TODO: test validations
    }
    /**
     * Stop subscription for previously published Demand.
     *
     * Stop receiving Proposals.  **Note**: this will terminate all pending &#x60;collectOffers&#x60; calls on this subscription. This implies, that client code should not &#x60;unsubscribeDemand&#x60; before it has received all expected/useful inputs from &#x60;collectOffers&#x60;. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void unsubscribeDemandTest() throws ApiException {
        String subscriptionId = null;
        api.unsubscribeDemand(subscriptionId);

        // TODO: test validations
    }
    /**
     * Waits for Agreement approval by the Provider.
     *
     * This is a blocking operation. The call may be aborted by Requestor caller code. After the call is aborted, another &#x60;waitForApproval&#x60; call can be raised on the same Agreement Id. It returns one of the following options: * &#x60;Approved&#x60; - Indicates that the Agreement has been approved by the Provider.   - The Provider is now ready to accept a request to start an Activity     as described in the negotiated agreement.   - The Providers’s corresponding &#x60;approveAgreement&#x60; call returns &#x60;Approved&#x60; after     this on the Provider side.  * &#x60;Rejected&#x60; - Indicates that the Provider has called &#x60;rejectAgreement&#x60;,   which effectively stops the Agreement handshake. The Requestor may attempt   to return to the Negotiation phase by sending a new Proposal.  * &#x60;Cancelled&#x60; - Indicates that the Requestor himself has called  &#x60;cancelAgreement&#x60;, which effectively stops the Agreement handshake. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void waitForApprovalTest() throws ApiException {
        String agreementId = null;
        Float timeout = null;
        String response = api.waitForApproval(agreementId, timeout);

        // TODO: test validations
    }
}
