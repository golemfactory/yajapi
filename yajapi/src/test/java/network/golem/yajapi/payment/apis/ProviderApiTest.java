/*
 * Yagna Payment API
 *  Invoicing and Payments is a fundamental area of Yagna Ecosystem functionality. It includes aspects of communication between Requestor, Provider and a selected Payment Platform, which becomes crucial when Activities are executed in the context of negotiated Agreements. Yagna applications must be able to exercise various payment models, and the Invoicing/Payment-related communication is happening in parallel to Activity control communication. To define functional patterns of Requestor/Provider interaction in this area, Payment API is specified.  An important principle of the Yagna Payment API is that the actual payment transactions are hidden behind the Invoice flow. In other words, a Yagna Application on Requestor side isn’t expected to trigger actual payment transactions. Instead it is expected to receive and accept Invoices raised by the Provider - based on Application’s Invoice Accept notifications, the Payment API implementation orchestrates the payment via a configured Payment platform.  **NOTE: This specification is work-in-progress.** 
 *
 * OpenAPI spec version: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package network.golem.yajapi.payment.apis;

import network.golem.yajapi.payment.ApiException;
import network.golem.yajapi.payment.models.Account;
import network.golem.yajapi.payment.models.Allocation;
import java.math.BigDecimal;
import network.golem.yajapi.payment.models.DebitNote;
import network.golem.yajapi.payment.models.ErrorMessage;
import network.golem.yajapi.payment.models.Invoice;
import network.golem.yajapi.payment.models.InvoiceEvent;
import java.time.OffsetDateTime;
import network.golem.yajapi.payment.models.Payment;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ProviderApi
 */
@Ignore
public class ProviderApiTest {

    private final ProviderApi api = new ProviderApi();

    /**
     * Cancel Debit Note.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already paid it. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        BigDecimal timeout = null;
        api.cancelDebitNote(debitNodeId, timeout);

        // TODO: test validations
    }
    /**
     * Cancel Invoice.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already paid it. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelInvoiceTest() throws ApiException {
        String invoiceId = null;
        BigDecimal timeout = null;
        api.cancelInvoice(invoiceId, timeout);

        // TODO: test validations
    }
    /**
     * Get incoming Payment.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIncomingPaymentTest() throws ApiException {
        String paymentId = null;
        Allocation response = api.getIncomingPayment(paymentId);

        // TODO: test validations
    }
    /**
     * Get incoming Payments.
     *
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIncomingPaymentsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<Payment> response = api.getIncomingPayments(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get Debit Note.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIssuedDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        DebitNote response = api.getIssuedDebitNote(debitNodeId);

        // TODO: test validations
    }
    /**
     * Get Debit Notes issued by this Provider.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIssuedDebitNotesTest() throws ApiException {
        List<DebitNote> response = api.getIssuedDebitNotes();

        // TODO: test validations
    }
    /**
     * Get Invoice.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIssuedInvoiceTest() throws ApiException {
        String invoiceId = null;
        Invoice response = api.getIssuedInvoice(invoiceId);

        // TODO: test validations
    }
    /**
     * Get Invoices issued by this Provider.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getIssuedInvoicesTest() throws ApiException {
        List<Invoice> response = api.getIssuedInvoices();

        // TODO: test validations
    }
    /**
     * Get Payments for Debit Note.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPaymentsForIssuedDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        List<Payment> response = api.getPaymentsForIssuedDebitNote(debitNodeId);

        // TODO: test validations
    }
    /**
     * Get Payments for issued Invoice.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPaymentsForIssuedInvoiceTest() throws ApiException {
        String invoiceId = null;
        List<Payment> response = api.getPaymentsForIssuedInvoice(invoiceId);

        // TODO: test validations
    }
    /**
     * Get Debit Note events.
     *
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getProviderDebitNoteEventsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<InvoiceEvent> response = api.getProviderDebitNoteEvents(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get Invoice events.
     *
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getProviderInvoiceEventsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<InvoiceEvent> response = api.getProviderInvoiceEvents(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get available accounts for receiving payments.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceiveAccountsTest() throws ApiException {
        List<Account> response = api.getReceiveAccounts();

        // TODO: test validations
    }
    /**
     * Issue a Debit Note.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void issueDebitNoteTest() throws ApiException {
        DebitNote body = null;
        DebitNote response = api.issueDebitNote(body);

        // TODO: test validations
    }
    /**
     * Issue an Invoice.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void issueInvoiceTest() throws ApiException {
        Invoice body = null;
        Invoice response = api.issueInvoice(body);

        // TODO: test validations
    }
    /**
     * Send Debit Note to Requestor.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void sendDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        BigDecimal timeout = null;
        api.sendDebitNote(debitNodeId, timeout);

        // TODO: test validations
    }
    /**
     * Send Invoice to Requestor.
     *
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void sendInvoiceTest() throws ApiException {
        String invoiceId = null;
        BigDecimal timeout = null;
        api.sendInvoice(invoiceId, timeout);

        // TODO: test validations
    }
}
