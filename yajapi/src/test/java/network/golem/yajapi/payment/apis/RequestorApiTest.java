/*
 * Yagna Payment API
 *  Invoicing and Payments is a fundamental area of Yagna Ecosystem functionality. It includes aspects of communication between Requestor, Provider and a selected Payment Platform, which becomes crucial when Activities are executed in the context of negotiated Agreements. Yagna applications must be able to exercise various payment models, and the Invoicing/Payment-related communication is happening in parallel to Activity control communication. To define functional patterns of Requestor/Provider interaction in this area, Payment API is specified.  An important principle of the Yagna Payment API is that the actual payment transactions are hidden behind the Invoice flow. In other words, a Yagna Application on Requestor side isn’t expected to trigger actual payment transactions. Instead it is expected to receive and accept Invoices raised by the Provider - based on Application’s Invoice Accept notifications, the Payment API implementation orchestrates the payment via a configured Payment platform.  **NOTE: This specification is work-in-progress.** 
 *
 * OpenAPI spec version: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package network.golem.yajapi.payment.apis;

import network.golem.yajapi.payment.ApiException;
import network.golem.yajapi.payment.models.Acceptance;
import network.golem.yajapi.payment.models.Account;
import network.golem.yajapi.payment.models.Allocation;
import java.math.BigDecimal;
import network.golem.yajapi.payment.models.DebitNote;
import network.golem.yajapi.payment.models.DebitNoteEvent;
import network.golem.yajapi.payment.models.ErrorMessage;
import network.golem.yajapi.payment.models.Invoice;
import network.golem.yajapi.payment.models.InvoiceEvent;
import java.time.OffsetDateTime;
import network.golem.yajapi.payment.models.Payment;
import network.golem.yajapi.payment.models.Rejection;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for RequestorApi
 */
@Ignore
public class RequestorApiTest {

    private final RequestorApi api = new RequestorApi();

    /**
     * Accept received Debit Note.
     *
     * Send Debit Note Accepted message to Debit Note Issuer. Trigger payment orchestration for this Debit Note (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged accepting the Invoice or timeout has passed.  NOTE: An Accepted Debit Note cannot be Rejected later. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void acceptDebitNoteTest() throws ApiException {
        Acceptance body = null;
        String debitNodeId = null;
        BigDecimal timeout = null;
        api.acceptDebitNote(body, debitNodeId, timeout);

        // TODO: test validations
    }
    /**
     * Accept received Invoice.
     *
     * Send Invoice Accepted message to Invoice Issuer. Trigger payment orchestration for this Invoice (using allocated lot identified by AllocationId if any).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: An Accepted Invoice cannot be Rejected later. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void acceptInvoiceTest() throws ApiException {
        Acceptance body = null;
        String invoiceId = null;
        BigDecimal timeout = null;
        api.acceptInvoice(body, invoiceId, timeout);

        // TODO: test validations
    }
    /**
     * Amend Allocation.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void amendAllocationTest() throws ApiException {
        Allocation body = null;
        String allocationId = null;
        Allocation response = api.amendAllocation(body, allocationId);

        // TODO: test validations
    }
    /**
     * Create Allocation.
     *
     * Allocate funds to make sure they are not spent elsewhere.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createAllocationTest() throws ApiException {
        Allocation body = null;
        Allocation response = api.createAllocation(body);

        // TODO: test validations
    }
    /**
     * Get Allocation.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getAllocationTest() throws ApiException {
        String allocationId = null;
        Allocation response = api.getAllocation(allocationId);

        // TODO: test validations
    }
    /**
     * Get Allocations.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getAllocationsTest() throws ApiException {
        List<Allocation> response = api.getAllocations();

        // TODO: test validations
    }
    /**
     * Get outgoing Payment.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getOutgoingPaymentTest() throws ApiException {
        String paymentId = null;
        Allocation response = api.getOutgoingPayment(paymentId);

        // TODO: test validations
    }
    /**
     * Get outgoing Payments.
     *
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getOutgoingPaymentsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<Payment> response = api.getOutgoingPayments(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get Payments for Debit Note.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPaymentsForReceivedDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        List<Payment> response = api.getPaymentsForReceivedDebitNote(debitNodeId);

        // TODO: test validations
    }
    /**
     * Get Payments for received Invoice.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPaymentsForReceivedInvoiceTest() throws ApiException {
        String invoiceId = null;
        List<Payment> response = api.getPaymentsForReceivedInvoice(invoiceId);

        // TODO: test validations
    }
    /**
     * Get Debit Note.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceivedDebitNoteTest() throws ApiException {
        String debitNodeId = null;
        DebitNote response = api.getReceivedDebitNote(debitNodeId);

        // TODO: test validations
    }
    /**
     * Get Debit Notes received by this Requestor.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceivedDebitNotesTest() throws ApiException {
        List<DebitNote> response = api.getReceivedDebitNotes();

        // TODO: test validations
    }
    /**
     * Get Invoice.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceivedInvoiceTest() throws ApiException {
        String invoiceId = null;
        Invoice response = api.getReceivedInvoice(invoiceId);

        // TODO: test validations
    }
    /**
     * Get Invoices received by this Requestor.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceivedInvoicesTest() throws ApiException {
        List<Invoice> response = api.getReceivedInvoices();

        // TODO: test validations
    }
    /**
     * Get Debit Note events.
     *
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getRequestorDebitNoteEventsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<DebitNoteEvent> response = api.getRequestorDebitNoteEvents(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get Invoice events.
     *
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. &#x60;laterThan&#x60; parameter can be used in order to get just the &#x27;new&#x27; events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getRequestorInvoiceEventsTest() throws ApiException {
        BigDecimal timeout = null;
        OffsetDateTime laterThan = null;
        List<InvoiceEvent> response = api.getRequestorInvoiceEvents(timeout, laterThan);

        // TODO: test validations
    }
    /**
     * Get available accounts for sending payments.
     *
     * 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getSendAccountsTest() throws ApiException {
        List<Account> response = api.getSendAccounts();

        // TODO: test validations
    }
    /**
     * Reject received Debit Note.
     *
     * Send Debit Note Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept the Debit Note (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Debit Note can be Accepted subsequently (e.g. as a result of some arbitrage). 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void rejectDebitNoteTest() throws ApiException {
        Rejection body = null;
        String debitNodeId = null;
        BigDecimal timeout = null;
        api.rejectDebitNote(body, debitNodeId, timeout);

        // TODO: test validations
    }
    /**
     * Reject received Invoice.
     *
     * Send Invoice Rejected message to Invoice Issuer. Notification of rejection is signalling that Requestor does not accept Invoice (for some reason).  This is a blocking operation. It will not return until the Requestor has acknowledged rejecting the Invoice or timeout has passed.  NOTE: A Rejected Invoice can be Accepted subsequently (e.g. as a result of some arbitrage). 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void rejectInvoiceTest() throws ApiException {
        Rejection body = null;
        String invoiceId = null;
        BigDecimal timeout = null;
        api.rejectInvoice(body, invoiceId, timeout);

        // TODO: test validations
    }
    /**
     * Release Allocation.
     *
     * The Allocation of amount is released. Note that this operation releases currently allocated amount (which may have been reduced by subsequent Invoice Payments).  If the Allocation was connected with a Deposit the release amount from Deposit shall be marked as pending to be paid back to Requestor - and eventually will be paid back, unless a subsequent Allocation with Deposit is made. The Payment Platform implementations may optimize unnecessary fund transfers (i.e. will not pay back the Deposit if released funds can be assigned to a new Allocation with Deposit). 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void releaseAllocationTest() throws ApiException {
        String allocationId = null;
        api.releaseAllocation(allocationId);

        // TODO: test validations
    }
}
