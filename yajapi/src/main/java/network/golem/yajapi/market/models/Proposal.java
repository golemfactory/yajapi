/*
 * Yagna Market API
 *  ## Yagna Market The Yagna Market is a core component of the Yagna Network, which enables computational Offers and Demands circulation. The Market is open for all entities willing to buy computations (Demands) or monetize computational resources (Offers). ## Yagna Market API The Yagna Market API is the entry to the Yagna Market through which Requestors and Providers can publish their Demands and Offers respectively, find matching counterparty, conduct negotiations and make an agreement.  This version of Market API conforms with capability level 1 of the <a href=\"https://docs.google.com/document/d/1Zny_vfgWV-hcsKS7P-Kdr3Fb0dwfl-6T_cYKVQ9mkNg\"> Market API specification</a>.  Market API contains two roles: Requestors and Providers which are symmetrical most of the time (excluding agreement phase). 
 *
 * OpenAPI spec version: 1.6.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package network.golem.yajapi.market.models;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import network.golem.yajapi.market.models.DemandOfferBase;
import java.io.Serializable;
/**
 * Proposal
 */


public class Proposal extends DemandOfferBase implements Serializable{
  private static final long serialVersionUID = 1L;
  @JsonProperty("proposalId")
  private String proposalId = null;

  @JsonProperty("issuerId")
  private String issuerId = null;

  /**
   * * &#x60;Initial&#x60; - proposal arrived from the market as response to subscription * &#x60;Draft&#x60; - bespoke counter-proposal issued by one party directly to other party (negotiation phase) * &#x60;Rejected&#x60; by other party * &#x60;Accepted&#x60; - promoted into the Agreement draft * &#x60;Expired&#x60; - not accepted nor rejected before validity period 
   */
  public enum StateEnum {
    INITIAL("Initial"),
    DRAFT("Draft"),
    REJECTED("Rejected"),
    ACCEPTED("Accepted"),
    EXPIRED("Expired");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static StateEnum fromValue(String text) {
      for (StateEnum b : StateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("state")
  private StateEnum state = null;

  @JsonProperty("prevProposalId")
  private String prevProposalId = null;

   /**
   * Get proposalId
   * @return proposalId
  **/
  @Schema(description = "")
  public String getProposalId() {
    return proposalId;
  }

   /**
   * Get issuerId
   * @return issuerId
  **/
  @Schema(description = "")
  public String getIssuerId() {
    return issuerId;
  }

   /**
   * * &#x60;Initial&#x60; - proposal arrived from the market as response to subscription * &#x60;Draft&#x60; - bespoke counter-proposal issued by one party directly to other party (negotiation phase) * &#x60;Rejected&#x60; by other party * &#x60;Accepted&#x60; - promoted into the Agreement draft * &#x60;Expired&#x60; - not accepted nor rejected before validity period 
   * @return state
  **/
  @Schema(description = "* `Initial` - proposal arrived from the market as response to subscription * `Draft` - bespoke counter-proposal issued by one party directly to other party (negotiation phase) * `Rejected` by other party * `Accepted` - promoted into the Agreement draft * `Expired` - not accepted nor rejected before validity period ")
  public StateEnum getState() {
    return state;
  }

  public Proposal prevProposalId(String prevProposalId) {
    this.prevProposalId = prevProposalId;
    return this;
  }

   /**
   * id of the proposal from other side which this proposal responds to 
   * @return prevProposalId
  **/
  @Schema(description = "id of the proposal from other side which this proposal responds to ")
  public String getPrevProposalId() {
    return prevProposalId;
  }

  public void setPrevProposalId(String prevProposalId) {
    this.prevProposalId = prevProposalId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Proposal proposal = (Proposal) o;
    return Objects.equals(this.proposalId, proposal.proposalId) &&
        Objects.equals(this.issuerId, proposal.issuerId) &&
        Objects.equals(this.state, proposal.state) &&
        Objects.equals(this.prevProposalId, proposal.prevProposalId) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(proposalId, issuerId, state, prevProposalId, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Proposal {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    proposalId: ").append(toIndentedString(proposalId)).append("\n");
    sb.append("    issuerId: ").append(toIndentedString(issuerId)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    prevProposalId: ").append(toIndentedString(prevProposalId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
